

![image-20240315232430405](C:\Users\rogers\AppData\Roaming\Typora\typora-user-images\image-20240315232430405.png)

![中大校名校徽-Green](C:\Program Files\Typora\media\image1.png)

# 			**本科生实验报告**

实验课程: 操作系统

任课教师: 刘宁

实验题目:内存管理

专业名称: 信息与计算科学

学生姓名:罗弘杰

学生学号: 22336173

实验地点: 实验中心D503

实验时间: 2024/3/15

## 				**Section 1 实验概述**

在本次实验中，我们首先学习如何使用**位图和地址池来**管理资源。然后，我们将**实现在物理地址空间下的内存管理。**接着，我们将会学习并**开启二级分页机制**。在开启分页机制后，我们将**实现在虚拟地址空间下的内存管理。**

本次实验最精彩的地方在于分页机制。基于分页机制，我们可以将连续的虚拟地址空间映射到不连续的物理地址空间。同时，对于同一个虚拟地址，在不同的页目录表和页表下，我们会得到不同的物理地址。这为实现虚拟地址空间的隔离奠定了基础。但是，本实验最令人困惑的地方也在于分页机制。开启了分页机制后，程序中使用的地址是虚拟地址。我们需要结合页目录表和页表才能确定虚拟地址对应的物理地址。而我们常常会忘记这一点，导致了我们不知道某些虚拟地址表示的具体含义。

##                   **Section 2 预备知识与实验环境**

- - 

##                             **Section 3 实验任务**



### 实验任务1：

复现实验7指导书中“物理页内存管理”一节的代码，实现物理页内存的管理，

具体要求如下： 

1. 结合代码分析位图，地址池，物理页管理的初始化过程，以及物理页进行分配和释放的实现 思路。 
2.  构造测试用例来分析物理页内存管理的实现是否存在bug。如果存在，则尝试修复并再次测 试。否则，结合测试用例简要分析物理页内存管理的实现的正确性。 
3. （不强制要求，对实验完成度评分无影响）如果你有想法，可以在自己的理解的基础上，参 考ucore，《操作系统真象还原》，《一个操作系统的实现》等资料来实现自己的物理页内 存管理。在完成之后，你需要指明相比指导书，你实现的物理页内存管理的特点。

### 实验任务2： 



### 实验任务3：



### 实验任务4：



## 			**Section 4 实验步骤与实验结果**

​	

### 	         ------------------------- 实验任务1-------------------------   

#### 任务要求：

​	复现实验7指导书中“物理页内存管理”一节的代码，实现物理页内存的管理，

具体要求如下： 

1. 结合代码分析位图，地址池，物理页管理的初始化过程，以及物理页进行分配和释放的实现 思路。 
2.  构造测试用例来分析物理页内存管理的实现是否存在bug。如果存在，则尝试修复并再次测 试。否则，结合测试用例简要分析物理页内存管理的实现的正确性。 
3. （不强制要求，对实验完成度评分无影响）如果你有想法，可以在自己的理解的基础上，参 考ucore，《操作系统真象还原》，《一个操作系统的实现》等资料来实现自己的物理页内 存管理。在完成之后，你需要指明相比指导书，你实现的物理页内存管理的特点。

#### 思路分析：

代码分析

```cpp
class BitMap
{
public:
    // 被管理的资源个数，bitmap的总位数
    int length;
    // bitmap的起始地址
    char *bitmap;
public:
    // 初始化
    BitMap();
    // 设置BitMap，bitmap=起始地址，length=总位数(即被管理的资源个数)
    void initialize(char *bitmap, const int length);
    // 获取第index个资源的状态，true=allocated，false=free
    bool get(const int index) const;
    // 设置第index个资源的状态，true=allocated，false=free
    void set(const int index, const bool status);
    // 分配count个连续的资源，若没有则返回-1，否则返回分配的第1个资源单元序号
    int allocate(const int count);
    // 释放第index个资源开始的count个资源
    void release(const int index, const int count);
    // 返回Bitmap存储区域
    char *getBitmap();
    // 返回Bitmap的大小
    int size() const;
private:
    // 禁止Bitmap之间的赋值
    BitMap(const BitMap &) {}
    void operator=(const BitMap&) {}
};
```

```cpp
class AddressPool
{
public:
    BitMap resources;
    int startAddress;
public:
    AddressPool();
    // 初始化地址池，参数为位图的起始地址，长度，以及地址池的开始地址
    void initialize(char *bitmap, const int length,const int startAddress);
    // 从地址池中分配count个连续页，成功则返回第一个页的地址，失败则返回-1
    int allocate(const int count);
    // 释放若干页的空间
    void release(const int address, const int amount);
};
```

```cpp

class MemoryManager
{
public:
    // 可管理的内存容量
    int totalMemory;
    // 内核物理地址池
    AddressPool kernelPhysical;
    // 用户物理地址池
    AddressPool userPhysical;
public:
    MemoryManager();

    // 初始化地址池
    void initialize();

    // 从type类型的物理地址池中分配count个连续的页
    // 成功，返回起始地址；失败，返回0
    int allocatePhysicalPages(enum AddressPoolType type, const int count);

    // 释放从paddr开始的count个物理页
    void releasePhysicalPages(enum AddressPoolType type, const int paddr, const int count);

    // 获取内存总容量
    int getTotalMemory();

};
```

​	可以看到这三个类是由底层到高层的关系，在初始化的时候内存管理器的初始化函数，会计算一些关键的参数（位图的起始，地址空间的页数，地址空间的开始），然后调用地址池的初始函数，地址池的初始化函数除了规定该地址池的起始地址，还会初始化该地址处的位图，调用位图的初始化函数，其中，位图的初始化函数会计算页数所需要的位图的大小，然后调用Memset在其起始地址开辟一定大小的空间

```cpp
// 内存管理器的初始化函数
    int usedMemory = 256 * PAGE_SIZE + 0x100000;
    if(this->totalMemory < usedMemory) {
        printf("memory is too small, halt.\n");
        asm_halt();
    }
    // 剩余的空闲的内存
    int freeMemory = this->totalMemory - usedMemory;

    int freePages = freeMemory / PAGE_SIZE;
    int kernelPages = freePages / 2; //计算可用的物理页的页数，平均分为内核空间和进程空间
    int userPages = freePages - kernelPages;

    int kernelPhysicalStartAddress = usedMemory;  //地址池的开始地址，也就是物理空间的起始
    int userPhysicalStartAddress = usedMemory + kernelPages * PAGE_SIZE;

    int kernelPhysicalBitMapStart = BITMAP_START_ADDRESS;  //位图开始地址
    int userPhysicalBitMapStart = kernelPhysicalBitMapStart + ceil(kernelPages, 8);

    kernelPhysical.initialize((char *)kernelPhysicalBitMapStart, kernelPages, kernelPhysicalStartAddress);
    userPhysical.initialize((char *)userPhysicalBitMapStart, userPages, userPhysicalStartAddress);
```

```cpp
// 地址池的初始化函数
void AddressPool::initialize(char *bitmap, const int length, const int startAddress)
{
    resources.initialize(bitmap, length);
    this->startAddress = startAddress;
}
```

```cpp
//位图的初始化函数
void BitMap::initialize(char *bitmap, const int length)
{
    this->bitmap = bitmap;
    this->length = length;

    int bytes = ceil(length, 8); //每一个字节对应一个页数，所以要计算除以8的天花板
    memset(bitmap, 0, bytes);

}
```

物理页分配和释放：

​	由于分配和释放几乎是类似而相反的操作，所以以下只分析分配的代码

```cpp
//内存管理器的分配函数，参数是地址空间的类型，需要的页数（页内存管理）
int MemoryManager::allocatePhysicalPages(enum AddressPoolType type, const int count)
{
    int start = -1;

    if (type == AddressPoolType::KERNEL)
    {
        start = kernelPhysical.allocate(count); //调用该地址池的分配函数
    }
    else if (type == AddressPoolType::USER)
    {
        start = userPhysical.allocate(count);
    }

    return (start == -1) ? 0 : start;
}

// 从地址池中分配count个连续页
int AddressPool::allocate(const int count)
{
    uint32 start = resources.allocate(count);  //查看位图中的记录，是否存在这样连续的内存页
    return (start == -1) ? -1 : (start * PAGE_SIZE + startAddress);
}


//位图的分配函数
int BitMap::allocate(const int count)
{
    if (count == 0)
        return -1;

    int index, empty, start;

    index = 0;
    while (index < length)
    {
        // 越过已经分配的资源
        while (index < length && get(index))
            ++index;

        // 不存在连续的count个资源
        if (index == length)
            return -1;

        // 找到1个未分配的资源
        // 检查是否存在从index开始的连续count个资源
        empty = 0;
        start = index;
        while ((index < length) && (!get(index)) && (empty < count))
        {
            ++empty;
            ++index;
        }

        // 存在连续的count个资源
        if (empty == count)
        {
            for (int i = 0; i < count; ++i)
            {
                set(start + i, true);
            }

            return start;
        }
    }

    return -1;
}
```

​	总的来说，内存管理器会根据内存空间的类型调用地址池的内存分配函数，在地址池中，位图实际上是用来记录页数是否已经分配，分配了置为1，没分配置为0，所以查看位图中是否存在这样数量的连续内存页就可以确定是否可以分配，可以的话， 通过计算位图中的index*pagesize+startaddress就可以正确来到可以满足要求的地址开始位置。

#### 测试分析

##### 测试代码：

```cpp
void first_thread(void *arg)
{
    //测试地址管理器是否正常工作
    uint32 a =memoryManager.allocatePhysicalPages(AddressPoolType::USER, 3);
    uint32 b =memoryManager.allocatePhysicalPages(AddressPoolType::USER, 16000);/
    uint32 c =memoryManager.allocatePhysicalPages(AddressPoolType::KERNEL, 1);
    uint32 d =memoryManager.allocatePhysicalPages(AddressPoolType::KERNEL, 16000);
    uint32 e =memoryManager.allocatePhysicalPages(AddressPoolType::USER, 2);
    
    printf("trying to allocate 3 page in USER space and succeed at a: %x\n", a);
    printf("trying to allocate 16000 page in USER space and fail from b: %x\n", b);
    printf("trying to allocate 1 page in KERNEL space and succeed at c: %x\n", c);
    printf("trying to allocate 16000 page in kERNEL space and fail from d: %x\n", d);
    printf("trying to allocate 2 page in USER space and succeed at e: %x\n", e);
    asm_halt();
}
```

##### 实验结果：	

​	可以看到地址返回都是正确的，而且可以判断页数是否足够，不足够的话就不会分配，在下一侧分配的时候，**根据连续内存分配的法则，会接着最近的可用地址空间来分配（由最后一个测试分配可以看出）。**

![image-20240520215639922](C:\Users\rogers\AppData\Roaming\Typora\typora-user-images\image-20240520215639922.png)

##### 



###                  ------------------------- **实验任务2**-------------------------

#### 任务要求：



#### 思路分析：





#### 实验步骤：

##### 

###### 代码展示：





2.移动字符的功能号为02h,  在这里我将行号和列号分别加一，即向右下角移动一次；

###### 成果展示：

##### （2）请修改Hello World的代码，**使用实模式下的中断来输出你的学号**。说说你是怎么做的，并将结果截图。



###### 代码分析：



###### 成果展示：



##### （

##### 代码展示：



##### 代码分析：



##### 成果展示：



### 		------------------------- 实验任务3-------------------------

#### 任务要求：!

#### 思路分析：

本题要求我们熟悉x86汇编的条件判断和循环和函数的结构。条件： cmp, je,jne,jz,jnz等等；循环： 使用cx寄

#### 代码分析：



#### 结果展示：



​	通过了测试。

###                        ------------------------- *实验任务*4 -------------------------

#### 任务要求：





#### 思路分析：



#### 代码分析：





#### 成果展示：







## **Section 5 实验总结与心得体会**

棘手的问题：linux内核版本不匹配，需要更新比较新的内核版本才可以正常进行qemu和gdb调试；

心得体会：初步认识到linux系统的启动过程，内核（kernel）初始化结束后，initramfs作为临时根文件系统被挂载，helloworld是最简单的一类，还没有实现根文件的系统，mybusybox中基于已有程序给出了根文件系统，使得操作系统可以正常启动。

## **Section 6 对实验的改进建议和意见**

1.  实验中的推荐使用linux-3的版本是否和最新的gdb和qemu平台不兼容？

2.  实验中的原理还需要阐释的更明白一些，很多命令行原理和Linux系统启动知识需要上网搜索，对于一些同学可能是不友好的。

## **Section 7 附录：参考资料清单**

本节为可选章节，可以列出自己在实验过程中的一些重要参考书籍、博客网站等等，为将来的实验提供帮助。

[linux启动流程——initrd和initramfs_initrd-switch-root" "initramfs-CSDN博客](https://blog.csdn.net/gengzhikui1992/article/details/85624879)

## **Section 8 附录：代码清单**

【实验任务3】完整的c程序如下：
